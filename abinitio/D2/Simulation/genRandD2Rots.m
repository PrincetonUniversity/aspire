
function [rots_grid]=genRandD2Rots(N,eqFilterAngle,s)
% Input parameters: 
% N  = Number of projections directions to sample on the sphere. 
% eqFilterAngle   Filter out projetions directions on a strip of width 
%                 2*eqFilterAngle about an equator (great circle on a 
%                 plane perpendicular to a symmetry axis).
% s = MATLAB seed (generated by rng() ) for reproducibility.
% Output:
% rots_grid   a set of rotations with random projection directions on the 
%             sphere, and filtered equator directions.  

%% Generate random grid on the sphere
rng(s);
rots_grid = rand_rots(N);
[sphere_grid]=squeeze(rots_grid(:,3,:))';
% octant1_idx=(sphere_grid(:,1)>0).*(sphere_grid(:,2)>0).*(sphere_grid(:,3)>0);
% sphere_grid=sphere_grid(octant1_idx==1,:);
% rots_grid=rots_grid(:,:,octant1_idx==1);
nrot=size(sphere_grid,1);

%% Filter points on equators
%project each vector onto xy,xz,yz planes and measure angular distance
sphere_grid=sphere_grid'; 
angular_dists=zeros(nrot,3);
proj_xy=sphere_grid;
proj_xy(3,:)=0;
norms_xy=sqrt(sum(proj_xy(1:2,:).^2,1));
proj_xy=proj_xy./repmat(norms_xy,3,1);
angular_dists(:,1)=dot(sphere_grid,proj_xy,1);
proj_xz=sphere_grid;
proj_xz(2,:)=0;
norms_xz=sqrt(sum(proj_xz([1,3],:).^2,1));
proj_xz=proj_xz./repmat(norms_xz,3,1);
angular_dists(:,2)=dot(sphere_grid,proj_xz,1);
proj_yz=sphere_grid;
proj_yz(1,:)=0;
norms_yz=sqrt(sum(proj_yz(2:3,:).^2,1));
proj_yz=proj_yz./repmat(norms_yz,3,1);
angular_dists(:,3)=dot(sphere_grid,proj_yz,1);

%filter points close to equators
eq_min_dist=cos(eqFilterAngle*pi/180);
filtered_idx=~sum(angular_dists>eq_min_dist,2)>0;
rots_grid=rots_grid(:,:,filtered_idx);

%% Generate rots_grid statistics for debuging
% latitude line angles and longitude values with respect to all symmetry 
% axes, angles between projection directions and 2 angles of spherical
% coordinates representation. 
%[grid_stats,pol_rep]=generateGridStats(rots_grid);
end