function OUTPUT=fastrotate(INPUT,phi,M)
%
%
% 3-step image rotation by shearing.
% This is an optimized version of fastrotate_ref.
% 
% Input parameters:
%  INPUT    Image to rotate, can be odd or even. If INPUT is a 3D array,
%           each slice is rotated by phi.
%  phi      Rotation angle in degrees CCW. Can be any angle (not limited
%           like fastrotate_ref). Note that Yaroslavsky's code take phi CW.
%  M        (Optional) Precomputed interpolation tables, as generated by
%           fastrotateprecomp. If M is given than phi is ignored. This is
%           useful if many images need to be rotated by the same angle,
%           since then the computation of the same interpolation tables
%           over and over again is avoided.
%
% Output parameters:
%  OUTPUT   The rotated image.
%
% Examples:
%
%   rim=fastrotate(im,20);
%
%   M=rotprecomp(size(im,1),size(im,2),20);
%   rim=fastrotate(im,[],M);
%
% Based on code by L. Yaroslavsky (yaro@eng.tau.ac.il). 
% The following changes have been implemented
%   1. Adapt to both odd and even sizes.
%   2. Avoid calling to fftnorm and ifftnorm. The overhead is too large.
%   3. Precompute Mx and My.   
%   4. Take Mx and My as parameters precomputed externally. 
%
% Yoel Shkolnisky, January 2011

[SzX SzY ~] =size(INPUT);

comp=0; % Determine if we need to compute the interpolation tables
if ~exist('M','var')
    comp=1;
elseif ~isstruct(M)
    comp=1;
elseif ~isfield(M,'Mx') || ~isfield(M,'My');
    comp=1;
else
    Mx=M.Mx;
    My=M.My;
end

if comp
    % Precompte My and Mx
    M=fastrotateprecomp(SzX,SzY,phi);
    Mx=M.Mx;
    My=M.My;
end

OUTPUT=zeros(size(INPUT));

for k=1:size(INPUT,3)
    
    % Rotate by multiples of 90 degrees.
    switch M.mult90
        case 0
        case 1
            INPUT(:,:,k)=rot90_fastrotate(INPUT(:,:,k));
        case 2
            INPUT(:,:,k)=rot180(INPUT(:,:,k));
        case 3
            INPUT(:,:,k)=rot270(INPUT(:,:,k));
        otherwise
            error('Invalid value for mult90');
    end
    
    %FIRST PASS
    % for x=1:SzX,
    %     spinput=fft(INPUT(x,:));
    %     spinput=spinput.*(My(:,x)).';
    %     OUTPUT(x,:)=real(ifft(spinput));
    % end
    
    spinput=fft(INPUT(:,:,k),[],2);
    spinput=spinput.*My;
    OUTPUT(:,:,k)=real(ifft(spinput,[],2));
    
    % SECOND PASS
    % for y=1:SzY,
    %     spinput=fft(OUTPUT(:,y));
    %     spinput=spinput.*Mx(:,y);
    %     OUTPUT(:,y)=real(ifft(spinput));
    % end
    
    spinput=fft(OUTPUT(:,:,k));
    spinput=spinput.*Mx;
    OUTPUT(:,:,k)=real(ifft(spinput));
    
    %THIRD PASS
    % for x=1:SzX,
    %     spinput=fft(OUTPUT(x,:));
    %     spinput=spinput.*(My(:,x)).';
    %     OUTPUT(x,:)=real(ifft(spinput));
    % end
    
    spinput=fft(OUTPUT(:,:,k),[],2);
    spinput=spinput.*My;
    OUTPUT(:,:,k)=real(ifft(spinput,[],2));
    
end
