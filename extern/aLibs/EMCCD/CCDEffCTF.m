function h = CCDEffCTF(n, binning, deNormalize)% f = CCDEffCTF(n, binning, denormalize);% This function was formerly called CCDSqrtDQE.% Compute a 2D array to multiply the result of CTF(n), to give the actual% CTF of a pre-whitened image acquired with our CCD camera.  The function% is the square root of the DQE as it is normally defined.  % Like CTF(), zero frequency is in the center of the returned 2D array, so% you will have to use fftshift before taking any IFFT.  By default% n=4096, the size of our CCD.% The binning argument is also optional, with default 1; if >1 it means% that the image being processed was binned, and therefore the maximum% frequency is that much smaller than Nyquist.% if deNormalize=1, the returned function is literally the sqrt(DQE) and% has a value smaller than unity at zero frequency.%% Example.  Compute a simulated image to compare with a pre-whitened% experimental image.  Let Obj be the true 2D image, e.g. a projection of a% 3D model, pixA be the angstroms per pixel, and CPars be a structure with% the CTF parameters (lambda, defocus, etc.)  Then,%% n=size(Obj,1);% h=CCDSqrtDQE(n).*CTF(n,res,CPars);% ObjFilt=real(ifftn(fftn(Obj).*fftshift(h)));%% fs 6 Nov 2010% added normalization 22 Apr 13if nargin<1    n=[4096 4096];  % Native size of the CCD.end;if nargin<2    binning=1;end;if nargin<3    deNormalize=0;end;if numel(n)<2    n=n*[1 1];end;fd=RadiusNorm(n)/binning;  % frequency relative to pixel pitchh=CCDModelMTF(fd)./sqrt(CCDModelSpectrum(fd));if ~deNormalize  % normalize to unity at low frequency    ctr=floor(n/2+1);    h=h/h(ctr(1),ctr(2));end;