function s=RadialPowerSpectrum(in)% function s=RadialPowerSpectrum(in);%% Compute the radially-averaged power spectrum of the rectangular image in,% returning the result in a row vector s.  If x is three-dimensional % (nx x ny x nim), compute the n x nim array of spectra from the stack% of nim images. To get the mean, compute mean(RadialPowerSpectrum(in),2)% For each image the DC component is subtracted and a window is used.% If x is nx x ny, n=min(nx,ny) then the returned vector s % has length floor(n/2).% s(1) is the zero-frequency component (=0 except for window error).% s(2) is the fs/n frequency component, (fs is the sampling frequency);% s(n/2) is the (fs/2 * (n-1)/n) frequency component.% The frequency step is fs/n.%% Modified to give unity output for white noise with unity pixel variance.% --fs 2 Sep 07[nx ny nim]=size(in);n=[nx ny];nr=floor(min(n)/2);accum=zeros(nr,nim);% Make a window of width n/8 around the edges.w=SquareWindow(n, ceil(nx/8));norm=w(:)'*w(:);  % Accounts for power attenuation due to the window.ws=sum(w(:));for i=1:nim    x=in(:,:,i);    % Remove DC component.    x=x-mean(x(:));        x=x.*w;  % Windowed signal    xs=sum(x(:));    x=x-w*(xs/ws); % Second round of DC subtraction.    % sum(wx(:))  % check DC subtraction        % Spectrum in rectangular coordinates    fs=fftshift(abs(fftn(x)).^2);    % x=[];  % save memory.    % w=[];    % Radial averaging    accum(:,i)=Radial2(fs);end;s=accum/norm;% ps=ToPolar(fs,n/2,2*n,1,n/2+1,n/2+1);% s=sum(ps')/(2*n*norm);