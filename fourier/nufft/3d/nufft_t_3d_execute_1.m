function g=nufft_t_3d_execute_1(beta,precomp)
%
% Compute the adjoint non-equally spaced FFT in three dimensions of the
% volume beta, using the preprocessing information precomp. Precomp
% determines the points where the transform is computed.
%
% This function is used to compute the transform of different volumes at
% the same set of points.
%
% The function computes the sums
%               n/2
%        g(j) = sum beta(k1,k2,k3)*exp(i*(k1,k2,k3)*x(j))
%             k1,k2,k3=-n/2
% for j=1,...,n.
%
% The complexity of the algorithm is O(n^3*log(1/eps)+(m*n)^3(log(n)))
%
% Input parameters:
%    beta       Volume to transform - real or complex. beta is assumed to
%               be a cubed volume.
%    precomp    Precomputed information generated by nufft_t_3d_prepare_1.
%    
% Output:
%    g        The sums defined above.
%
% See nufft_t_3d_prepare_1.
%
% Yoel Shkolnisky, February 2010.

if ndims(beta)~=3
    error('beta must be a cubed volume');
end

if (size(beta,1)~=size(beta,2)) || (size(beta,1)~=size(beta,2))
    error('beta must be a cubed volume');
end

n=precomp.n;
m=precomp.m;
b=precomp.b;

if (n~=size(beta,1))
    error('Size of beta is different from n used in precomputation (nufft_t_3d_prepare_1)');
end

low_idx=-ceil((n-1)/2);
high_idx=floor((n-1)/2);
idx=low_idx:high_idx;
E=exp(b.*(2.*pi.*idx./(m*n)).^2);
E=E(:);
EE=E*E.';
E3=zeros(n,n,n);
for k=1:n
    E3(:,:,k)=EE.*E(k);
end

u=beta.*E3;

low_idx_u=ceil((m*n-1)/2);
w=zeros(m*n,m*n,m*n);
w(low_idx_u+low_idx+1:low_idx_u+low_idx+1+n-1,...
  low_idx_u+low_idx+1:low_idx_u+low_idx+1+n-1,...
  low_idx_u+low_idx+1:low_idx_u+low_idx+1+n-1)=u;

W=fftshift(ifftn(ifftshift(w)));
W=W*numel(W);

g=nufftt3dexecutemx_1(W,precomp);
