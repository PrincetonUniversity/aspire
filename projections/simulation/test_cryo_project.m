%% Test the functions for generating projections.
%
% Example code for 
%   1. generating test phantoms, analytic projections, and
% their Fourier transforms.
%   2. projecting arbitrary volumes.
%
% Yoel Shkolnisky, August 2013.

%% Test 1: Test the function project against direct summation.
% Compare projection in the z direction to direct summation of the volume
% along the z direction.

initstate;

clear;
voldef='C1_params';  % Can be 'one_ball' for a simpler phantom.
rot = eye(3);       % Identity rotation - projection along the z direction.
n=65;               % Size of the projections. Can be even or odd.
rmax=1;              % The volume is generated by sampling the phantom on 
                     % a 3D Cartesian grid where each dimension has n
                     % samples on [-rmax,rmax]
vol=cryo_gaussian_phantom_3d(voldef,n,rmax);  % Generate the nxnxn volume.
p1=cryo_project(vol,rot);   % Project the volume in the z direction.
p2=sum(vol ,3);      % Sum the volume in the z direction. 
subplot(1,3,1);imagesc(p1); colorbar; axis image;
subplot(1,3,2);imagesc(p2); colorbar; axis image;
subplot(1,3,3); imagesc(p2-p1); colorbar; axis image;
err=norm(p1(:)-p2(:))/norm(p1(:));
disp(err); % Error should be close to machine precision.

%% Test 2: Compare direct summation against analytic projection
% Compare direct summation of the volume along the z-axis to the analytic
% projection computed along the z direction.

clear;
voldef='C1_params';  % Can be 'one_ball' for a simpler phantom.
rot = eye(3);       % Identity rotation - projection along the z direction.
n=65;                % Size of the projections. Can be even or odd.
                     % Sampling must be sufficient for the projected
                     % (Guassian) phantom.
rmax=1;              % The value of n must be large enough for the given 
                     % rmax. See "Test 1" for more details.
vol=cryo_gaussian_phantom_3d(voldef,n,rmax); % Generate the nxnxn volume.

% To convert from a sum to an integral, the normalization factor is
% different for odd and even sizes.
if mod(n,2)==1
    dz=2*rmax/(n-1);
else
    dz=2*rmax/n;
end
p1=sum(vol ,3)*dz; % Sum along the z direction and multiply by dz 
                   % to convert the sum to an integral.
p2=cryo_project_gaussian(voldef,n,rmax,rot); % Compute analytic projection.
subplot(1,3,1);imagesc(p1); colorbar; axis image;
subplot(1,3,2);imagesc(p2); colorbar; axis image;
subplot(1,3,3); imagesc(p2-p1); colorbar; axis image;
err=norm(p1(:)-p2(:))/norm(p1(:));
disp(err); % Error should be close to machine precision.

%% Test 3: Compare the function "project" against analytic projections
% Numerically project a sampled phantom and compre the result to the
% corresponding analytic projection.

clear;
voldef='C1_params'; % Can be 'one_ball' for a simpler phantom.
rot = rand_rots(1);       % Some random rotation.
n=128;              % Size of the projections. Can be even or odd.
                    % Sampling must be sufficient for the Guassian
rmax=1;             % See "Test 2" for more details..
vol=cryo_gaussian_phantom_3d(voldef,n,rmax); % Generate the nxnxn volume.

% To convert cryo_project to an analytical projection, we need to multiply
% by a normalization factor (which requires knowing the physical dimensions
% of the projected object. This normalization factor is different for odd
% and even sizes. 
if mod(n,2)==1
    dz=2*rmax/(n-1);
else
    dz=2*rmax/n;
end


p1=cryo_project(vol,rot)*dz; % Project the volume and multiply by dz to 
                           % convert the discrete projection (summation
                           % along the direction specified by q) into an
                           % integral. 
p2=cryo_project_gaussian(voldef,n,rmax,rot); % Compute analytic projection.
subplot(1,3,1);imagesc(p1); colorbar; axis image;
subplot(1,3,2);imagesc(p2); colorbar; axis image;
subplot(1,3,3); imagesc(p2-p1); colorbar; axis image;
err=norm(p1(:)-p2(:))/norm(p1(:));
disp(err); % Error should be close to machine precision. If not, check if 
           % rmax is large enough so that the given phantom is essentially
           % compactlly supported, and that n is large enough for a 
           % sufficient sampling rate. 

%% Test 4: Compare the analytic Fourier transform of a projection to its cfft 
% For a given rotation rot, generate the points in which to sample the
% Fourier transform of the projection according to the Fourier
% projection-slice theorem. Once the points are given, sample the Fourier
% transform using gaussian_f3, and take the inverse cfft. The result should
% be identical to the analytic projection corresponding to the rotation.

clear;
voldef='C1_params';
rot = rand_rots(1);
n=129; % Can be even or odd.
rmax=1;

% Generate frequency sampling grid

if mod(n,2)==1
    rng=(-(n-1)/2:(n-1)/2); 
    t=rng./ ((n-1)/2)*rmax;
else
    rng=(-n/2+1/2:n/2-1/2);
    t=rng./(n/2)*rmax;
end

[I,J]=ndgrid(rng,rng); 
I=I(:); J=J(:);
R=rot;
Rt=R.';
n_x= Rt(:,1); 
n_y= Rt(:,2);
P = I * n_x' + J * n_y';
T0=(t(2)-t(1))*n;
omega0=2*pi/T0;
P= omega0.*P;

vals=cryo_gaussian_ft(voldef,P); % Sample the analytic Fourier transform of the
                             % volume at the point P
vals=reshape(vals,n,n);

if mod(n,2)==1
    p1=icfft2(vals);
else
    p1=icfft2e(vals);
end
p1=p1.*(n/T0)^2; % Convert the icfft into inverse Fourier transform by 
                 % proper normalization. (n/T0)^2 is actually equal to
                 % ((n-1)/(2*rmax))^2. 


assert(max(abs(imag(p1(:))))<1.0e-14); % The imaginary components in the 
                                       % computed projection should be tiny.
p1=real(p1); % Get rid of tiny imaginary components, if any.

p2=cryo_project_gaussian(voldef,n,rmax,rot); % Compute analytic projection.
subplot(1,3,1); imagesc(p1);  colorbar; axis image;
subplot(1,3,2); imagesc(p2);  colorbar; axis image;
subplot(1,3,3); imagesc(p2-p1); colorbar; axis image;
err=norm(p1(:)-p2(:))/norm(p1(:));
disp(err);  % Error should be close to machine precision.


%% Test 5: Compare cfft of an analytic slide to the analytic Fourier transform.
% Compute an analytic slice of the Fourier transform, take its inverse
% Fourier transform (using icfft) and compare the result to the analytic
% projection. 
% This also shows the normalization factor involved.

clear;
voldef='C1_params';
rot = rand_rots(1);
rmax=2; % I used larger rmax just to show that other rmax work too.
n=256; % Should be large enough for the given rmax.
[p1hat,nf]=cryo_gaussian_ft_slice(voldef,n,rmax,rot);

if mod(n,2)==1
    p1=icfft2(p1hat);
else
    p1=icfft2e(p1hat);
end
p1=p1.*nf; 
assert(max(abs(imag(p1(:))))<1.0e-14)
p1=real(p1);

p2=cryo_project_gaussian(voldef,n,rmax,rot);
subplot(1,3,1); imagesc(p1); colorbar; axis image;
subplot(1,3,2); imagesc(p2); colorbar; axis image;
subplot(1,3,3); imagesc(p2-p1); colorbar; axis image;
err=norm(p1(:)-p2(:))/norm(p1(:));
disp(err); % Error should be close to machine precision.

%% Test 6: Another test of the Fourier slice theorem.
% Compute an analytic projection, take its Fourier transform (using cfft2),
% and compare the result to the analytic Fourier transform.

clear;
voldef='C1_params';
rot = rand_rots(1);
n=256;
rmax=1;
[p1hat,nf]=cryo_gaussian_ft_slice(voldef,n,rmax,rot);
p2=cryo_project_gaussian(voldef,n,rmax,rot);

if mod(n,2)==1
    p2hat=cfft2(p2)./nf;
else
    p2hat=cfft2e(p2)./nf;
end
err=norm(p1hat(:)-p2hat(:))/norm(p1hat(:));
disp(err); % Error should be close to machine precision.

%% Test 7: Another test for the function "project".
% Create a volume, project it, and take the cfft of the projection. This
% should be equal to the analytical Fourier transform of the projection. 

clear;
voldef='C1_params'; 
rot = rand_rots(1);
n=128; 
rmax=1;
vol=cryo_gaussian_phantom_3d(voldef,n,rmax);

if mod(n,2)==1
    dz=2*rmax/(n-1);
else
    dz=2*rmax/n;
end

p1=cryo_project(vol,rot)*dz; % =cryo_project_gaussian(voldef,n,rmax,rot);
%p2=cryo_project_gaussian(voldef,n,rmax,rot);
%norm(p1(:)-p2(:))/norm(p1(:)); % Intermediate test. Should be tiny.

if mod(n,2)==1
    nf=((n-1)/(2*rmax))^2; % Nromalization factor.
    p1hat=cfft2(p1)./nf; 
else
    nf=(n/(2*rmax))^2; % Nromalization factor. 
    p1hat=cfft2e(p1)./nf; 
end
p2hat=cryo_gaussian_ft_slice(voldef,n,rmax,rot);
err=norm(p1hat(:)-p2hat(:))/norm(p1hat(:));
disp(err); % Error should be close to machine precision.


%% Test 8: Finally compare project to gen_projections

[P1,~,~,rots]=cryo_gen_projections(1,1,0,1);
n=size(P1,1);
%volref=cryo_gaussian_phantom_3d('C1_params',n,1);
load cleanrib
P2=cryo_project(volref,rots,n);
P2=permute(P2,[2 1]);
subplot(1,3,1); imagesc(P1); colorbar; axis image;
subplot(1,3,2); imagesc(P2); colorbar; axis image;
subplot(1,3,3); imagesc(P1-P2); colorbar; axis image;
err=norm(P1(:)-P2(:))/norm(P1(:));
disp(err)

